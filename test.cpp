#include <stdio.h>
#include <stdlib.h>
#include <iostream>

using std::cout;
using std::endl;
// 1. 内存对齐是牺牲空间换时间 提高获取数据的效率 --> 内存读取数据是按数据块来读取的
// (1. 减少读取数据的次数 (2. 简化解析数据的过程
// #pragma pack(1) // 若默认对齐数为1, 则大小为17  --> 预处理指令修改对齐数

/*2. this 指针: 只能在"成员函数"内部使用
	类型: 类类型* const
	出现: 普通的成员函数中, 作为成员函数的第一个形参, 
	所以不同的对象调用同一个成员函数,会产生不同的结果
this 指针如果不做解引用的话, 是可以为空指针的; 否则 就会出现解引用异常
3. 构造函数: 
	作用: 初始化对象的成员 
	函数名与类名相同, 无返回值, 可以重载
	如果不显示定义构造函数, 编译器会自动生成一个默认的构造函数(默认构造的函数是无参的)
	若是有显示定义的构造函数, 编译器就不会再去生成一个默认构造函数, 除非我们自己定义个无参构造函数
	全缺省的也算是默认构造函数, 但是默认函数只能存在一个,
	(1. 要么不写,编译器自己生成; 2. 无参; 3. 全缺省(所有的参数都被初始化了) --> 一般操作)
	如果已经显示定义了, 编译器将不再默认生成
	创建对象时, 编译器根据参数的个数自动调用对应参数个数的构造函数(有参的调有参的, 无参的调无参的)
	编译器自动调用构造函数来初始化 ,我们自己不能调用, 不用再调设置函数

	无参构造后面不能加();
	Data a;  前提必须自己显示定义一个无参构造函数, 
	Data a();  相当于是一个函数的声明 没有实际的指令

	如果类中有自定义成员, 当前类的构造函数会去自动调用 自定义成员 的默认构造函数 完成自定义成员的初始化

4. 析构函数: 帮助我们清理资源(不是销毁对象), 资源包括堆上的资源, 打开的文件, 网络连接
	如果对象时一个局部变量, 编译器会帮我们自动销毁
	也是编译器自动调用(在对象的生命周期结束时, 编译器自动调用析构函数 完成对资源的清理
	函数名: ~类名(){}            无参无返回值, 不能重载
	如果不定义, 编译器也会帮我们自动生成
	如果类中有自定义成员, 当前类的析构函数会去自动调用 自定义成员 的析构函数 完成自定义成员的资源清理

*/
class A{
	int _a;// 4
	char _c;// 4 + 1 = 5
	double _d;// 5+3+ 8 = 16
	float _e;// 16 + 4 = 20
	struct B{
		int _a;// 4
		char _c;//5
		float _f;//12
	};// 12  如果没有下面那一句 则不算在A结构体大小里 大小不算他, 
	// B _b; 若有了这一句 才是32 
};// 最终大小按最大对齐数的倍数 = 8n = 24

union C{
	int _a;
	char _c;
};

void test1(){
	cout << sizeof(A) << endl; // 24
}
void test2(){
	C c;
	c._c = 1;
	if (c._c == 1)
		cout << "小端" << endl;
	else
		cout << "大端" << endl;
	
	int a = 1;
	char* pa = (char*)&a;
	if (*pa == 1)
		cout << "小端" << endl;
	else
		cout << "大端" << endl;

}

void test3(){
	A a;
	char* pa = (char*)&a;
	char* pe = (char*)&a._e;
	cout << pe - pa << endl;


}

int main(){
	test1();
	/*int a = 10;
	cout << "a = " << a << endl;
*/
	system("pause");
	return 0;
}